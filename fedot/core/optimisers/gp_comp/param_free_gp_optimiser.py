from typing import List, Optional, Union, Any

from fedot.core.composer.gp_composer.gp_composer import PipelineComposerRequirements
from fedot.core.log import Log
from fedot.core.optimisers.gp_comp.gp_optimiser import EvoGraphOptimiser, GPGraphOptimiserParameters
from fedot.core.optimisers.gp_comp.iterator import SequenceIterator, fibonacci_sequence
from fedot.core.optimisers.gp_comp.operators.inheritance import GeneticSchemeTypesEnum
from fedot.core.optimisers.gp_comp.parameters.mutation_prob import AdaptiveMutationProb
from fedot.core.optimisers.gp_comp.parameters.population_size import PopulationSize, AdaptivePopulationSize
from fedot.core.optimisers.optimizer import GraphGenerationParams
from fedot.core.optimisers.objective.objective import Objective

DEFAULT_MAX_POP_SIZE = 55


class EvoGraphParameterFreeOptimiser(EvoGraphOptimiser):
    """
    Implementation of the parameter-free adaptive evolutionary optimiser
    (population size and genetic operators rates is changing over time).
    For details, see https://ieeexplore.ieee.org/document/9504773
    """

    def __init__(self, initial_graph: Union[Any, List[Any]],
                 objective: Objective,
                 requirements: PipelineComposerRequirements,
                 graph_generation_params: GraphGenerationParams,
                 parameters: Optional[GPGraphOptimiserParameters] = None,
                 max_population_size: int = DEFAULT_MAX_POP_SIZE,
                 log: Log = None):
        super().__init__(initial_graph, objective, requirements, graph_generation_params, parameters, log)

        self._min_population_size_with_elitism = 7
        if self.parameters.genetic_scheme_type != GeneticSchemeTypesEnum.parameter_free:
            self.log.warn(f'Invalid genetic scheme type was changed to parameter-free. Continue.')
            self.parameters.genetic_scheme_type = GeneticSchemeTypesEnum.parameter_free

        # Define adaptive parameters
        pop_size_progression = SequenceIterator(sequence_func=fibonacci_sequence,
                                                start_value=requirements.pop_size,
                                                min_sequence_value=1, max_sequence_value=max_population_size)
        self._pop_size: PopulationSize = AdaptivePopulationSize(self.generations, pop_size_progression)
        self._mutation_rate = AdaptiveMutationProb()

    def _operators_prob_update(self):
        if not self.generations.is_any_improved:
            mutation_prob = self._mutation_rate.next(self.population)
            crossover_prob = 1. - mutation_prob
            self.requirements.mutation_prob = mutation_prob
            self.requirements.crossover_prob = crossover_prob
